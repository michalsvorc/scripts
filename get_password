#!/usr/bin/env python3
#
# Generates a consistent password from user inputs.
#
# Version: 1.0.0
# Author: Michal Svorc <dev@michalsvorc.com>
# License: MIT license (https://opensource.org/licenses/MIT)
# Guidelines: https://google.github.io/styleguide/pyguide

import argparse
import subprocess
import hashlib
import getpass
import string
import sys
import platform
from typing import List, Dict

DERIVATION_ITERATIONS = 100000
PASSWORD_LENGTH = 256
SALT = b"salt"
CHARSET = string.ascii_letters + string.digits + "!@#$%^&*()_-+={}[]|\\;:'\"<,>.?/"


def main():
    args = parse_arguments()
    input_string = get_input("Enter input string: ")
    input_password = get_password("Enter password: ")
    key = derive_key(input_string, input_password, args.length)
    password = generate_password(key, args.length)

    if args.clipboard:
        if copy_to_clipboard(password):
            print("Password copied to clipboard.")
        else:
            print("Failed to copy password to clipboard. Ensure xclip is installed.")
            sys.exit(1)
    else:
        print()
        print(password)


def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Generate a consistent strong password based on inputs."
    )
    parser.add_argument(
        "-c",
        "--clipboard",
        action="store_true",
        help="Copy the password to the clipboard instead of printing it.",
    )
    parser.add_argument(
        "-l",
        "--length",
        type=int,
        default=PASSWORD_LENGTH,
        help="Length of the generated password.",
    )
    return parser.parse_args()


def get_input(prompt: str) -> str:
    return input(prompt)


def get_password(prompt: str) -> str:
    return getpass.getpass(prompt)


def derive_key(input_str: str, password: str, password_length: int) -> bytes:
    hash_name = "sha256"
    combined = (input_str + password).encode()
    return hashlib.pbkdf2_hmac(
        hash_name, combined, SALT, DERIVATION_ITERATIONS, password_length
    )


def generate_password(key: bytes, password_length: int) -> str:
    return "".join(CHARSET[b % len(CHARSET)] for b in key[:password_length])


def copy_to_clipboard(text: str) -> bool:
    clipboard_commands: Dict[str, List[str]] = {
        "Darwin": ["pbcopy"],
        "Linux": ["xclip", "-selection", "clipboard"],
    }

    system = platform.system()
    command = clipboard_commands.get(system)

    if not command:
        raise NotImplementedError(
            f"Clipboard functionality not implemented for OS: {system}"
        )

    assert command is not None

    try:
        subprocess.run(command, input=text.encode(), check=True)
        return True
    except subprocess.CalledProcessError:
        return False


if __name__ == "__main__":
    main()
